# Autogenerated with SMOP version 
# /usr/local/bin/smop eulerTension.m

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def eulerTension_(L=None,diameter=None,Q=None,Vg=None,Vbias=None,h=None,cRatio=None,dBdz=None,Sz=None,TPrime_0=None,zPrime_0=None,stepCount=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 12-[L,diameter,Q,Vg,Vbias,h,cRatio,dBdz,Sz,TPrime_0,zPrime_0,stepCount].count(None)+len(args)

    spatialElements=100000.0
    epsilon=1e-10
    xiL_UpperLimit=25
    xiL_LowerLimit=0.03
    effectiveCapLengthRatio=1
    if not isempty_(varargin):
        nVarIn=length_(varargin[1])
        if rem_(nVarIn,2) == 1:
            error_(char('Expects an even number of varargin, using identifier followed by value'))
        else:
            for k in arange_(1,nVarIn / 2).reshape(-1):
                tag=varargin[1][2 * k - 1]
                if strcmp_(tag,char('effCapLenRatio')):
                    effectiveCapLengthRatio=varargin[1][2 * k]
                else:
                    error_(char('Unrecognized varargin tag'))
    rOut=diameter / 2
    rIn=rOut - wallThickness
    mCNT=rhoA * 0.735 * pi * diameter * L
    A=pi * (rOut ** 2)
    momentInertia=(pi / 4) * (rOut ** 4)
    lengthDensity=pi * diameter * rhoA
    Cg=4 * pi * epsilon0 * L * effectiveCapLengthRatio / (2 * log_(2 * h / rOut))
    C=cRatio * Cg
    CL=(C - Cg) / 2
    a=zPrime_0 * L
    K_electric=(1.0 / (4 * pi * epsilon0 * L ** 2 * h)).dot((1 / cRatio) ** 2.0) * (C.dot(Vg) - CL * Vbias) ** 2
    F_mag=g * muB * dBdz * Sz
    T_0=TPrime_0 * E * momentInertia / L ** 2
    step=arange_(1,stepCount)
    TInit=T_0 + (E * A / 24 * (K_electric ** 2 * L ** 2 + 3 * K_electric * L * F_mag + 3 * F_mag ** 2)) ** (1 / 3)
    if abs_(sqrt_(TInit / (E * momentInertia)) * L) < 1:
        TInit=T_0 + K_electric ** 2 * L ** 6 * A / (60480 * E * momentInertia ** 2) + F_mag ** 2 * L ** 4 * A / (30720 * E * momentInertia ** 2)
    threshold=abs_(epsilon * TInit)
    z=linspace_(0,L,spatialElements)
    dz=z[2] - z[1]
    dxdz=zeros_(1,spatialElements)
    counter=1
    escapeIn=99999999
    aIndex=floor_(spatialElements * zPrime_0)
    halfIndex=floor_(spatialElements / 2)
    quarterIndex=floor_(spatialElements / 4)
    threeQuarterIndex=spatialElements - quarterIndex
    for j in step.reshape(-1):
        xi=sqrt_(TInit / (E * momentInertia))
        if 0:
            fprintf_(char('Area0\\n'))
            cosh_xiL_minusOne=((xi * L) ** 2) / 2 + ((xi * L) ** 4) / 24 + ((xi * L) ** 6) / 720 + ((xi * L) ** 8) / 40320
            sinh_xiL=(xi * L) + ((xi * L) ** 3) / 6 + ((xi * L) ** 5) / 120 + ((xi * L) ** 7) / 5040
            cosh_xiZ_minusOne=((xi * z) ** 2) / 2 + ((xi * z) ** 4) / 24 + ((xi * z) ** 6) / 720 + ((xi * z) ** 8) / 40320
            sinh_xiZ=(xi * z) + ((xi * z) ** 3) / 6 + ((xi * z) ** 5) / 120 + ((xi * z) ** 7) / 5040
            x=zeros_(1,spatialElements)
            x=(K_electric * L / (2 * TInit * xi)) * ((sinh_xiL * cosh_xiZ_minusOne / cosh_xiL_minusOne) - sinh_xiZ + xi * z - xi * z ** 2 / L)
            x[1:halfIndex]=x[1:halfIndex] + (F_mag / (2 * E * momentInertia * xi ** 3) * (tanh_(xi * L / 4) * (cosh_(xi * z[1:halfIndex]) - 1) - sinh_(xi * z[1:halfIndex]) + xi * z[1:halfIndex]))
            x[(halfIndex + 1):end()]=x[(halfIndex + 1):end()] + (F_mag / (2 * E * momentInertia * xi ** 3) * (tanh_(xi * L / 4) * (cosh_(xi * (L - z[(halfIndex + 1):end()])) - 1) - sinh_(xi * (L - z[(halfIndex + 1):end()])) + xi * (L - z[(halfIndex + 1):end()])))
        else:
            dangerZ=xiL_UpperLimit / abs_(xi)
            if 1:
                x=(K_electric * L / (2 * TInit * xi)) * ((sinh_(xi * L) / (cosh_(xi * L) - 1)) * (cosh_(xi * z) - 1) - sinh_(xi * z) + xi * z - xi * z ** 2 / L)
                sinhka=sinh_(xi * a)
                sinhkL=sinh_(xi * L)
                sinhkLa=sinh_(xi * (L - a))
                coshka=cosh_(xi * a)
                coshkL=cosh_(xi * L)
                coshkLa=cosh_(xi * (L - a))
                FPrime=F_mag / (E * momentInertia)
                k=copy_(xi)
                sigma1=FPrime * (sinhka - sinhkL + sinhkLa + a * k + k * (L - a) * coshkL - L * k * coshkLa)
                sigma2=L * k * sinhkL - 2 * coshkL + 2
                sigma3=FPrime * (coshkL - coshka + coshkLa - k * (L - a) * sinhkL - 1)
                c1=sigma3 / (k * sigma2)
                c2=sigma1 / (k * sigma2)
                c3=- sigma3 / (k ** 2 * sigma2)
                c4=- sigma1 / (k ** 3 * sigma2)
                z1=z[1:aIndex]
                z2=z[aIndex + 1:end()]
                x[1:aIndex]=x[1:aIndex] + c1 * sinh_(k * z1) / k ** 2 + c2 * cosh_(k * z1) / k ** 2 + c3 * z1 + c4
                x[aIndex + 1:end()]=x[aIndex + 1:end()] + FPrime * sinh_(k * (z2 - a)) / k ** 3 - FPrime * (z2 - a) / k ** 2 + c1 * sinh_(k * z2) / k ** 2 + c2 * cosh_(k * z2) / k ** 2 + c3 * z2 + c4
            else:
                fprintf_(char('Error: entered uncoded region\\n'))
                __,dangerIndex=min_(abs_(z - dangerZ),nargout=2)
                dangerIndex2=spatialElements - dangerIndex
                x=zeros_(1,spatialElements)
                x[1:dangerIndex]=(K_electric * L / (2 * TInit * xi)) * ((sinh_(xi * L) / (cosh_(xi * L) - 1)) * (cosh_(xi * z[1:dangerIndex]) - 1) - sinh_(xi * z[1:dangerIndex]) + xi * z[1:dangerIndex] - xi * z[1:dangerIndex] ** 2 / L)
                x[(dangerIndex + 1):(dangerIndex2 - 1)]=(K_electric * L / (2 * TInit * xi)) * (- 1 + xi * z[(dangerIndex + 1):(dangerIndex2 - 1)] - xi * z[(dangerIndex + 1):(dangerIndex2 - 1)] ** 2 / L)
                x[dangerIndex2:end()]=(K_electric * L / (2 * TInit * xi)) * ((sinh_(xi * L) / (cosh_(xi * L) - 1)) * (cosh_(xi * z[dangerIndex + 1:- 1:1]) - 1) - sinh_(xi * z[dangerIndex + 1:- 1:1]) + xi * z[dangerIndex2:end()] - xi * z[dangerIndex2:end()] ** 2 / L)
                if halfIndex < dangerIndex:
                    x[1:halfIndex]=x[1:halfIndex] + (F_mag / (2 * E * momentInertia * xi ** 3) * (tanh_(xi * L / 4) * (cosh_(xi * z[1:halfIndex]) - 1) - sinh_(xi * z[1:halfIndex]) + xi * z[1:halfIndex]))
                    x[(halfIndex + 1):end()]=x[(halfIndex + 1):end()] + (F_mag / (2 * E * momentInertia * xi ** 3) * (tanh_(xi * L / 4) * (cosh_(xi * (L - z[(halfIndex + 1):end()])) - 1) - sinh_(xi * (L - z[(halfIndex + 1):end()])) + xi * (L - z[(halfIndex + 1):end()])))
                else:
                    if quarterIndex < dangerIndex:
                        x[1:quarterIndex]=x[1:quarterIndex] + (F_mag / (2 * TInit * xi)) * (tanh_(xi * L / 4) * (cosh_(xi * z[1:quarterIndex]) - 1) - sinh_(xi * z[1:quarterIndex]) + xi * z[1:quarterIndex])
                        x[quarterIndex + 1:halfIndex]=x[quarterIndex + 1:halfIndex] + (F_mag / (2 * TInit * xi)) * (- 2 - tanh_(xi * L / 4) * (cosh_(xi * z[quarterIndex:- 1:1]) - 1) + sinh_(xi * z[quarterIndex:- 1:1]) + xi * z[quarterIndex + 1:halfIndex])
                        x[halfIndex + 1:threeQuarterIndex]=x[halfIndex + 1:threeQuarterIndex] + (F_mag / (2 * TInit * xi)) * (- 2 - tanh_(xi * L / 4) * (cosh_(xi * (L - z[end():- 1:threeQuarterIndex + 1])) - 1) + sinh_(xi * (L - z[end():- 1:threeQuarterIndex + 1])) + xi * (L - z[halfIndex + 1:threeQuarterIndex]))
                        x[threeQuarterIndex + 1:end()]=x[threeQuarterIndex + 1:end()] + (F_mag / (2 * TInit * xi)) * (tanh_(xi * L / 4) * (cosh_(xi * (L - z[threeQuarterIndex + 1:end()])) - 1) - sinh_(xi * (L - z[threeQuarterIndex + 1:end()])) + xi * (L - z[threeQuarterIndex + 1:end()]))
                    else:
                        x[1:dangerIndex]=x[1:dangerIndex] + (F_mag / (2 * E * momentInertia * xi ** 3) * (tanh_(xi * L / 4) * (cosh_(xi * z[1:dangerIndex]) - 1) - sinh_(xi * z[1:dangerIndex]) + xi * z[1:dangerIndex]))
                        x[dangerIndex + 1:(halfIndex - dangerIndex)]=x[dangerIndex + 1:(halfIndex - dangerIndex)] + (F_mag / (2 * TInit * xi)) * (- 1 + xi * z[dangerIndex + 1:(halfIndex - dangerIndex)])
                        x[(halfIndex - dangerIndex + 1):halfIndex]=x[(halfIndex - dangerIndex + 1):halfIndex] + (F_mag / (2 * TInit * xi)) * (- 2 - tanh_(xi * L / 4) * (cosh_(xi * z[dangerIndex:- 1:1]) - 1) + sinh_(xi * z[dangerIndex:- 1:1]) + xi * z[(halfIndex - dangerIndex + 1):halfIndex])
                        x[(halfIndex + 1):(halfIndex + dangerIndex)]=x[(halfIndex + 1):(halfIndex + dangerIndex)] + (F_mag / (2 * TInit * xi)) * (- 2 - tanh_(xi * L / 4) * (cosh_(xi * (L - z[end():- 1:dangerIndex2 + 1])) - 1) + sinh_(xi * (L - z[end():- 1:dangerIndex2 + 1])) + xi * (L - z[(halfIndex + 1):(halfIndex + dangerIndex)]))
                        x[(halfIndex + dangerIndex + 1):dangerIndex2]=x[(halfIndex + dangerIndex + 1):dangerIndex2] + (F_mag / (2 * TInit * xi)) * (- 1 + xi * (L - z[(halfIndex + dangerIndex + 1):dangerIndex2]))
                        x[dangerIndex2 + 1:end()]=x[dangerIndex2 + 1:end()] + (F_mag / (2 * E * momentInertia * xi ** 3) * (tanh_(xi * L / 4) * (cosh_(xi * (L - z[dangerIndex2 + 1:end()])) - 1) - sinh_(xi * (L - z[dangerIndex2 + 1:end()])) + xi * (L - z[dangerIndex2 + 1:end()])))
        dxdz[1]=(x[2] - x[1]) / dz
        for count in arange_(2,(spatialElements - 1)).reshape(-1):
            dxdz[count]=(x[count + 1] - x[count - 1]) / (2 * dz)
        dxdz[spatialElements]=(x[spatialElements] - x[spatialElements - 1]) / dz
        T[j]=T_0 + E * A / (2) * sum_(dxdz ** 2) / spatialElements
        TInit=(0.6 + 0.37 * j / stepCount) * TInit + (0.4 - 0.37 * j / stepCount) * T[j]
        T[j]=TInit
        if j > 2 and abs_(T[j] - T[j - 1]) < threshold and escapeIn > 10:
            escapeIn=3
        if escapeIn < 1:
            break
        if counter > 25 and abs_(T[j] - T[j - 24]) < (10000.0 * threshold):
            counter=1
            TInit=mean_(T[j - 10:j])
            T[j]=TInit
        counter=counter + 1
        escapeIn=escapeIn - 1
    maxx=max_(abs_(x))
    return T,maxx,step,x,z,dxdz,K_electric,F_mag
